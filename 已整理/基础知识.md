##并发与锁
	基本概念
		多线程-并发-临界资源-同步-死锁
		sleep，yield，join,wait,interrupt
		wait、notify、notifyAll、Condition
		上下文切换，临界区，守护与用户线程，死锁
	内存模型
		内存-高速缓存-cpu
		主内存-工作内存-线程
		工作内存中保存了主内存共享变量的副本
		8个原子性操作：lock,unlock，read，load，use,assign,store，write
		**synchronized保证原子性，可见性，有序性（串行相当于单线程）**
		**volatile保证了可见性，有序性（Happens-before原则）**
		原子性
			一个不可中断的操作
			操作系统
				单核：主内存与工作内存之间的8个操作原子性，使得基本数据类型读写不可中断（有些jvm不保证64位）
				多核：总线锁定，缓存锁定，缓存一致性协议
			java: 锁（synchronized）
		可见性
			修改后的数据对所有线程立即可见
			volatile
				保证能看见其他线程对变量的修改
					read、load、use操作，须连续一起出现，每次use时，都从主内存read，工作内存load主内存的值
				保证其他线程可以看到自己对变量的修改
					assign、store、write操作，须连续一起出现，工作内存中的每次修改，须立刻同步回主内存
			synchronized：串行后线程读取的都是变量的最新值
		有序性
			指令重排：
				为了优化性能(最大化利用缓存)，编译器的默认行为（编译器重排序和运行时重排序）
				依据：as-if-serial，程序的结果不变，故重排序不会发生在有数据依赖的操作之中
			单线程：
				所有操作都是有序的
				单线程下，虽然指令重排，但结果一样，故单线程始终有序
			多线程：
				发生指令重排后，可能会影响程序预期结果
				只有禁止重排，才能保证有序性
				禁止重排原则：Happens-before（8个规定，包含volatile,当符合该8个规定时，指令不会重排）
				案例：双重check的单例模式
					 instance = new Singleton();  //非原子操作
					 memory =allocate();    //1：分配对象的内存空间 
					 ctorInstance(memory);  //2：初始化对象 
					 instance =memory;     //3：设置instance指向刚分配的内存地址
					 重排后可能为1,3,2 多线程下获取到的instance可能为空，即未初始化
					 解决办法：private volatile static Singleton instance = null;
		内存屏障/栅栏
			一种CPU指令，用于控制特定条件下的重排序和内存可见性问题
			相关指令
				read/write
				load/store
			栅栏：粗粒度，栅栏前的load,store指令一定在栅栏后的load,store指令之前执行,开销大
			屏障：细粒度
				StoreStore
				LoadStore
				StoreLoad
				LoadLoad
		伪共享
		合并写
		管程
	同步方法（原理，应用）
		synchronized
			lock,unlock
			monitorenter,monitorexit	
		JUC
			ReetrantLock
			Atomics
		ThreadLocal
	锁优化
		时间-减少持有时间
		粒度-减少锁的范围
		类型-读写代替独占
		无锁，偏向锁，轻量锁，重量锁
	JUC底层
		CAS
			旧的预期值A，当前内存值V、即将更新的值B
			Unsafe
				valueOffset-获取变量的偏移地址，从而获取内存中的值
				compareAndSwapInt
					原子操作
					本地方法
					靠缓存锁定保证多核下的原子性
					比较预期值和当前内存值，相同则修改，返回true---否则轮训获取最新内存值继续调用compareAndSwapInt直到成功
			volatile：保证变量可见性,轮训时时获取最新值
			缺点
				循环时间长-可限制自旋次数
				只保证一个共享变量原子操作
				ABA问题-加版本解决
		AQS
			state状态 
				volatile
				cas获取同步状态
			同步队列
				双向链表
					node(pre next)
					头结点-当前获取到同步状态的结点
					尾节点
				自旋CAS-将获取同步状态失败的线程封装成节点添加到队列尾部，保证线程安全
				内部死循环获取同步状态(只有老二节点有资格)-成功或阻塞
				线程排队,阻塞,唤醒
			获取状态
				获取失败后加入队列阻塞等待唤醒
			释放状态
				释放成功后唤醒next节点线程
			独占 共享
			tryAcquire tryAcquireShared tryRelease tryReleaseShared
	JUC实现
		LOCK
			独占锁 读写锁
		原子类
			AtomicStampedReference
		阻塞队列
		并发容器
		线程池
		并发工具类
			CountDownLatch
				线程之间的等待，控制线程在其他线程组执行任务后才能执行
			CyclicBarrier
				线程组内的相互等待，所有线程执行到一定状态后才能往下执行
			Semaphore
				信号量，控制线程并发的数量
			异步编程/线程编排 Callable、Future、FutureTask、CompletableFuture
			并行计算 fork/join

##网络编程
	五种io模式：
		阻塞 非阻塞 信号驱动 io复用 异步
		同步io：前四种都是同步io，io复用本质上也是同步I/O，因为都需要在读写事件就绪后自己负责进行读写，读写过程是阻塞的
		异步io: 异步I/O无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间
		阻塞：等待读写就绪会阻塞
		非阻塞：轮训读写，未就绪做其他事		
		读数据：将内核数据拷贝到用户空间  读就绪---数据到达内核空间
		写数据：将用户数据拷贝到内核  写就绪---内核空间未满
	名词
		内核空间&用户空间
			隔离内核程序和普通程序，保证安全性
			将虚拟存储空间划分为两部分内核空间和用户空间
		描述符
			表述指向文件的引用的抽象化概念，linux一切皆文件
			打开或创建文件时会返回文件描述符
		句柄
		服务器监听端口-最大连接数-描述符		
	socket处理
		Read request
		Decode request
		Process service
		Encode reply
		Send reply
	reactor模型
		原理
			连接进来时，不直接处理，告诉内核监听该连接的读写事件，当有事件发生时再丢到线程池处理,单线程处理了所有连接
		模式
			事件驱动机制 观察者模式 反应器
		核心
			描述符
				整数值，识别事件，socket连接，读写事件
			事件分离器
				demultiplexer
				循环等待事件
				使用io复用技术：select、poll、epoll等系统调用，用来等待一个或多个事件的发生
				将I/O复用技术封装成统一的接口，称为事件多路分离器
				调用者会被阻塞，直到描述符集上有事件发生
			事件处理器
				具体读写连接事件的处理，继承后实现处理函数
			Reactor管理器
				注册、删除事件处理器和相关的描述符
				使用事件分离器来等待事件的发生。一旦事件发生，分离每个事件，然后调度具体的事件处理器
			应用程序
				要做的仅仅是实现具体的事件处理器，然后把它注册到Reactor管理器中
		io复用技术
			通过一种机制，监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作
			select
				1.将fd集合从用户空间拷贝到内核空间
				2.调用select函数监视是否有fd就绪
					驱动中poll()函数执行 
					有数据返回mask掩码通知应用程序
					无数据返回0睡眠等待唤醒
				3.select返回后，将fd集合从内核空间拷贝到用户空间
				4.遍历fd集合找到就绪的fd
				5.支持的fd数量为1024（内核指定），可以使用多进程解决（Apache就是这样实现的）
			poll
				1.和select相似
				2.描述fd集合的方式不同，使用pollfd表示三个fd_set
				3.没有最大限制，但数量大性能也会下降
				4.同样需要遍历fd集合才能找到就绪的fd
			epoll			
				事件
					epitem结构体
					包含句柄和监控的事件类型
				epoll_create
					建立一个epoll对象（申请一个简易的文件系统）
					eventpoll结构体
						红黑树-存储需要监控的事件
						双链表-存储发生了的事件
				epoll_ctl
					向epoll对象添加进来的事件,挂载在红黑树中(红黑树插入高效)
					事件会与设备驱动程序建立回调关系
					当事件发生时，调用ep_poll_callback，将发生的事件添加到双链表中
				epoll_wait
					检查eventpoll对象中的双链表中是否有epitem元素，有则复制到用户空间
				高效
					红黑树 --- 不用将描述符从用户空间复制到内核
					双链表 --- 用户空间不用遍历获取就绪的描述符
					回调机制 --- 内核不用遍历
					100万个客户端同时与一个服务器进程保持着TCP连接，每一时刻，通常只有几百上千个TCP连接是活跃的
				工作模式
					LT：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件
					ET：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件
			线程模型
				单线程监听
				单线程监听+读写线程池
				多线程监听+读写线程池
	proactor模型
		事件分离器+回调函数
		Reactor模式
			事件分离者等待事件发生后传给事先注册的事件处理函数或者回调函数
			回调函数来做实际的读写操作
		Proactor模式
			直接发起一个异步读写操作，而实际的工作是由操作系统来完成的
			例如读事件发起时，需要提供的参数包括用于存放读到数据的缓存区，读的数据大小，以及这个请求完后的回调函数等信息
			事件分离者得知了这个请求，它默默等待这个请求的完成，然后调用回调函数处理
			回调函数处理时数据已经读写到缓存区，不用自己去做实际的读写操作
	NIO
		实现了reactor模式
		1.4,1.5使用的select、poll技术，1.8使用的epoll技术
		选择器
			单线程处理多通道，非阻塞模式（channel继承SelectableChannel）
			事件
				connect，accept，read，write
				不同channel可以注册的事件集合不同
				注册，处理，取消
			选择键（SelectionKey）
				通道，选择器，attach数据，感兴趣事件，已准备事件
				已注册键集合，已选择键集合，已取消键集合
				interestOps()
				readyOps()
				cancel()
				attach()
				attachment()
		通道
			register() 注册
			类型
		        FileChannel：从文件中读写数据。
		        DatagramChannel：能通过UDP读写网络中的数据。
		        SocketChannel：能通过TCP读写网络中的数据。
		        ServerSocketChannel：可以监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannel。
			读数据：通道到缓冲区
			写数据: 缓存区到通道
		缓存区
			capacity--容量  position--位置  limit--限制
			1.分配缓冲区 allocate（）
			1.将数据写入缓冲区     ---- 写模式
			2.调用buffer.flip（）  ---- 写入模式切换到读取模式
			3.从缓冲区读取数据     ---- 读模式
			4.清除缓冲区
				buffer.clear（）   ---- 清除所有
				buffer.compact（） ----清除已读
	

##jvm
	类加载
		作用
			运行时首次引用一个类，加载链接初始化该class文件
			不会一次加载所有类，一个类只被加载一次
		过程
			加载
				类加载器
					启动类加载器 -- 启动类路径 -- rt.jar
					扩展类加载器 -- ext目录 -- jre/lib
					应用程序类加载器 -- 应用程序级别
				双亲委派模型
					父类加载器能完成加载则成功，否则自己加载
			链接
				校验 -- 字节码是否正确
				准备 -- 分配内存并初始化静态变量(默认值)
				解析 -- 常量池内的符号引用替换为直接引用（String s ="aaa",转化为 s的地址指向“aaa”的地址）
			初始化
				赋值给静态变量
				执行静态代码块
				发生条件：主动引用，被动引用不发生
	内存模型
		堆
			数据
				对象和数组
			划分
				新生代
					新对象
					Eden+2survivor
				老年代
					老对象
				创建对象在eden，然后minor gc后到survivor，最后到老年代，大对象或数组直接进入老年代
		栈
			局部变量、操作数栈，对象引用
			线程-栈
			函数-帧
			StackOverflowError
			OutOfMemoryError
		方法区	
			静态变量
			类信息
				字段，方法
				静态常量池（编译时确定）
					字面量
						final常量
						字符串常量
						基本类型数据
					符号引用
						接口类字段方法名
			动态常量池
				避免频繁的创建和销毁对象
				包含静态常量池内容
				还能动态添加，运行阶段添加常量到常量池（例如基本类型包装类-128，127）
				字符串常量池在1.6之后被移到堆内存
		本地方法栈
			线程-本地栈
			执行Native方法
		程序计算器
			线程私有
			线程所执行的字节码的行号指示器
		堆外内存
			应用程序直接访问，避免堆内存与内核空间来回复制，nio Buffer有用到（socket--堆外内存--应用程序）
	执行引擎
		执行运行时数据区的字节码
	GC
		对象移动
			eden--survivor(来回复制)--年老代
			大对象或数组直接放入年老代（避免频繁内存拷贝）
		触发时间
			minor gc
				eden满
				将eden对象和FormSurvive拷贝到ToSurvive,然后位置互换
				Survival区有两块，一块称为from区，另一块为to区，这两个区是相对的，在发生一次Minor GC后，from区就会和to区互换
			full gc
				老年代满
					1，from survive中对象的生命周期到一定阈值
					2，分配的对象直接是大对象
					3，由于To 空间不够，进行monir GC直接把对象拷贝到年老代
		gc对象
			引用链找不到的对象
			弱引用对象
			软引用对象（内存不足时）
			finalize -- 回收之前调，资源清理
		收集算法
			引用计数法 -- 互相引用导致无法回收
			GC Root
				没有被GC Root引用就会被 垃圾回收器标记为可回收垃圾
				1、虚拟机栈（栈中的本地变量表）中引用的对象；
				2、方法区中类静态属性引用的对象；
				3、方法区中常量引用的对象；
				4、本地方法栈中JNI（即一般说的Native方法）引用的对象。
		回收算法
			复制-删除  -- 复制存活对象 删除全部 -- 浪费内存 适合存活较少
			标记-清除  -- 标记后直接清除未标记对象 -- 容易产生内存碎片
			标记-整理  -- 将存活对象压缩到内存一端，清除另一端 -- 存活多耗时
		垃圾回收器
			回收器就是垃圾算法的实现
			##串行收集器
			    -XX:+UseSerialGC：策略为年轻代串行复制，年老代串行标记整理
			##并行收集器
			    -XX:+UseParallelGC
			    年轻代：暂停应用程序，多个垃圾收集线程并行的复制收集，线程数默认为CPU个数，CPU很多时，可用-XX:ParallelGCThreads= 设定线程数。
			    年老代：暂停应用程序，与串行收集器一样，单垃圾收集线程标记整理。
			##并发收集器
			    -XX:+UseConcMarkSweepGC
			    年轻代：同样是暂停应用程序，多个垃圾收集线程并行的复制收集。
			    年老代：则只有两次短暂停，其他时间应用程序与收集线程并发的清除。
			##增量并发收集器
			    在并发标记、清理的时候让GC线程、用户线程交叉运行，尽量减少GC线程的全程独占式执行
		内存泄漏
			程序在向系统申请分配内存空间后(new)，在使用完毕后未释放
		内存溢出
			程序向系统申请的内存空间超出了系统能给的
	调优
		参数

##集合
	概述
		Iterator：hasNext,next,remove
		collection
		数组：连续内存，随机访问性好，不可动态扩容
		list：有序，可重复
		set：无序，唯一，底层结构有map包装
		map：键值对，键唯一
		queuq: 队列
	list
		ArrayList
			动态数组，查询块，增删慢
		vector
			结构同arraylist相似，线程安全
			stack
		LinkedList
			底层结构是链表，查询慢，增删快
			实现Deque接口
	map
		HashMap
			hash表
			equals hashcode
			重写方法时保证equals和hashcode结果一致
		HashTable
			数据结构同hashmap，线程安全
			Properties
		LinkedHashMap
			链表和hash表
			链表保证有序性，hash表保证唯一
		TreeMap（SortMap）
			红黑树
			equals compareTo 重写方法时保证equals和compareTo结果一致
			自然排序
				key要实现Comparable接口实现compareTo方法
			定制排序
				创建时传Comparator接口实现compare方法
		WeakHashMap
			强引用，不销毁不回收
		EnumMap
			key为枚举类的值，创建指定枚举类型
		IdentityHashMap
			判断是否key相同key1==key2,而不是equals和hashcode
	set
		HashSet
		LinkedHashSet
		TreeSet
		EnumSet
	Deque
		双端队列，两边都可以插入删除，可以当队列和栈使用
		ArrayDeque
			数组实现的双端队列
		LinkedList
			链表实现的双端队列
	实现
		ArrayList
		HashMap
			null-0
			hashcode hash(hashcode) hash冲突
			Entry数组 Entry链表
			负载因子 扩容 resize两倍 rehash
			大小-2的幂次
	常用操作
		集合遍历
		集合遍历删除
		map遍历
		collections
		Arrays

##面向对象
	面向对象特点
	    1.抽象
	    	抽象是将一类对象的共同特征总结出来构造类的过程
	    2.封装
	    	把数据和操作数据的方法绑定起来
	    3.继承
	    	软件的重用性
	    4.多态
	    	不同子类型的对象对同一消息作出不同反应
	重写与重载
		重载是一个类多个方法相同名字，不同参数
		重写是继承父类后对方法的重新实现
	抽象类与类
	    抽象类：包含抽象方法的类，使用abstract关键字声明，但抽象类也可以不包含抽象方法（没有意义）
	    1）抽象方法必须为public（默认）或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法）
	    2）抽象类不能用来创建对象
	    3）父类继承抽象类要么实现其抽象方法要么将本身声明为抽象类
	抽象类与接口
	    1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；
	    2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
	    3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法
	    4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。
	内部类
	    成员内部类
	        可以访问外部类的私有或静态属性，编译时默认为内部类添加一个指向外部类的指针，public时，要创建内部类对象必须先创建外部类对象，依赖于外部类，拥有的访问权限有public private protected 和默认权限
	    匿名内部类
	        通常此类的对象是作为一个参数传递到方法中，例如监听器没有访问权限，主要是解决代码冗余问题，是唯一一个没有构造器的类，用于继承类或接口重写或实现其中的方法，用于接口回调，编译时期由系统自动起名，调用外部内的变量必须用final修饰
	    静态内部类
	        不依赖外部类，不能访问外部类的非静态变量    
	    使用场景
	        为什么在Java中需要内部类？总结一下主要有以下四点：
	        1.内部类使得多继承的解决方案变得完整，
	        2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。
	        3.方便编写事件驱动程序
	        4.方便编写线程代码
	关键字
	    static
	        特征
	            1.存放在方法区，共享，可直接通过class调用
	            2.静态方法内不能包含非静态方法和属性
	            3.静态代码块只执行一次（在new对象或调用类的静态方法时都会触发）
	        调用类的过程
	            1.触发了类的对象构造
	            2.调用.class的静态代码块
	            3.在堆上分配空间
	            4.存储空间清零
	            5.初始化属性字段（这就是为啥属性会有默认值的原因）
	            6.调用构造函数
	    final
	        1.可以用来修饰变量，方法，类
	        2.被修饰的类不能被继承，类中所有属性被隐似设为final
	        3.被修饰的方法不能被重写，会将方法转为内嵌调用
	        4.被修饰的变量若是基本类型，初始化后值不能被修改，若是引用类型，引用不能在指向其他的对象，若是成员变量，要在定义时或构造器内初始化，若是局部变量，保证在使用之前被初始化即可
	        5.匿名内部类使用外部成员的变量必须用final修饰
	    tranisent
	        1、transient关键字只能修饰非静态变量，而不能修饰方法和类。
	        2、被transient关键字修饰的变量不再能被序列化，静态变量不管是否被transient修饰，均不能被序列化。
	对象的初始化顺序
	    静态变量=静态快>成员变量=非静态代码块>构造函数 (相同层级 父>子)
	作用域
	    作用域 当前类 同一package 子孙类 其他package 
	    public       √          √           √            √ 
	    protected √         √            √            × 
	    default    √         √            ×            × 
	    private     √         ×            ×             × 
	    外部类的修饰符只能是public或默认
	基本数据类型
	    8个基本类型：byte、short、int、long、float、double、char、boolean；
	    除了基本类型和枚举类型，剩下的都是引用类型
	    switch支持byte,short,int,char以及枚举,字符串
	装箱拆箱
	    - 原始类型: boolean，char，byte，short，int，long，float，double
	    - 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double
	    - 基础类型和包装类型可以自动转换
	    装箱的本质是什么呢
	        当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf

##设计模式
	分类
		创建型
			对象的实例化过程进行抽象
			工厂 单例 建造者
		结构型
			多个类和对象组合得到复杂结构的类
			适配器 装饰者 代理
		行为型
			表达对象和类的交互
			责任链 迭代器 观察者
	应用
		责任链
			对象串联，每个对象都有机会处理请求
			Tomcat中Filter链
		工厂模式
			不同条件获取不同bean，统一管理
			spring中BeanFactory
		单例模式
			共用一个实例对象
			spring中bean创建
		原型模式
			使用不同的实例对象
			spring中bean创建
		适配器模式
			系统后期通过适配方式统一接口
			spring aop中继承MethodInterceptor
		建造者模式
			将复制对象的创建屏蔽到接口内部
			Mybatis中的SqlSessionFactoryBuilder
		观察者模式
			对象的状态或者属性发生变化时候，通知其他对这些状态感兴趣的对象
			Spring中ApplicationListener
	单例模式
		饿汉式
			启动直接创建
		懒汉式
			需要时创建
			volatile+双重check+syn

##http协议
	无状态协议 cookie
	组成
		请求
			请求行
				请求方法 url http版本
			请求头
				content-type
				accept
				cookie
				host/referer
				user-agent
			请求体
		响应
			响应行
				状态码 http版本
			响应头
				content-type
				content-length
				content-encoding
				keep-alive
			响应体
	content-type
		form-data: 可传文件的表单
		muti/urlEncodeing：表单键值对
		raw
			json
			xml
			text
	statu code
		200：正常
		301：永久重定向
		302：临时重定向
		401：需要认证
		404：无法找到资源
		500：内部错误
	版本
		1.0
			keep-alive设置长连接
		1.1
			默认长连接
			body可为空
		2.0
			数据压缩
			支持websocket
	https
		ssl+http
		加密传输 身份认证
		过程
			公钥->客户端
			客户端生成对称密钥
			公钥加密对称密钥
			私钥解密对称密钥
			使用对称密钥加密通信
	三次握手&四次挥手
		三次握手
			1.客户端请求连接 syn
			2.服务器发送ack+syn报文
			3.客户端发送ack报文
		四次挥手
			1.client发送fin报文
			2.server ack应答
			3.server发送fin报文
			4.客户端发送ack报文
	长连接与短连接
		长连接
			操作频繁，连接数少
			数据库
			网络游戏
			聊天室
		短连接
			操作频率低，并发量大
			网站服务