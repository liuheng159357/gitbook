##jvm
	类加载
		作用
			运行时首次引用一个类，加载链接初始化该class文件
			不会一次加载所有类，一个类只被加载一次
		过程
			加载
				类加载器
					启动类加载器 -- 启动类路径 -- rt.jar
					扩展类加载器 -- ext目录 -- jre/lib
					应用程序类加载器 -- 应用程序级别
				双亲委派模型
					父类加载器能完成加载则成功，否则自己加载
			链接
				校验 -- 字节码是否正确
				准备 -- 分配内存并初始化静态变量(默认值)
				解析 -- 常量池内的符号引用替换为直接引用（String s ="aaa",转化为 s的地址指向“aaa”的地址）
			初始化
				赋值给静态变量
				执行静态代码块
				发生条件：主动引用，被动引用不发生
	内存模型
		堆
			数据
				对象和数组
			划分
				新生代
					新对象
					Eden+2survivor
				老年代
					老对象
				创建对象在eden，然后minor gc后到survivor，最后到老年代，大对象或数组直接进入老年代
		栈
			局部变量、操作数栈，对象引用
			线程-栈
			函数-帧
			StackOverflowError
			OutOfMemoryError
		方法区	
			静态变量
			类信息
				字段，方法
				静态常量池（编译时确定）
					字面量
						final常量
						字符串常量
						基本类型数据
					符号引用
						接口类字段方法名
			动态常量池
				避免频繁的创建和销毁对象
				包含静态常量池内容
				还能动态添加，运行阶段添加常量到常量池（例如基本类型包装类-128，127）
				字符串常量池在1.6之后被移到堆内存
		本地方法栈
			线程-本地栈
			执行Native方法
		程序计算器
			线程私有
			线程所执行的字节码的行号指示器
		堆外内存
			应用程序直接访问，避免堆内存与内核空间来回复制，nio Buffer有用到（socket--堆外内存--应用程序）
	执行引擎
		执行运行时数据区的字节码
	GC
		对象移动
			eden--survivor(来回复制)--年老代
			大对象或数组直接放入年老代（避免频繁内存拷贝）
		触发时间
			minor gc
				eden满
				将eden对象和FormSurvive拷贝到ToSurvive,然后位置互换
				Survival区有两块，一块称为from区，另一块为to区，这两个区是相对的，在发生一次Minor GC后，from区就会和to区互换
			full gc
				老年代满
					1，from survive中对象的生命周期到一定阈值
					2，分配的对象直接是大对象
					3，由于To 空间不够，进行monir GC直接把对象拷贝到年老代
		gc对象
			引用链找不到的对象
			弱引用对象
			软引用对象（内存不足时）
			finalize -- 回收之前调，资源清理
		收集算法
			引用计数法 -- 互相引用导致无法回收
			GC Root
				没有被GC Root引用就会被 垃圾回收器标记为可回收垃圾
				1、虚拟机栈（栈中的本地变量表）中引用的对象；
				2、方法区中类静态属性引用的对象；
				3、方法区中常量引用的对象；
				4、本地方法栈中JNI（即一般说的Native方法）引用的对象。
		回收算法
			复制-删除  -- 复制存活对象 删除全部 -- 浪费内存 适合存活较少
			标记-清除  -- 标记后直接清除未标记对象 -- 容易产生内存碎片
			标记-整理  -- 将存活对象压缩到内存一端，清除另一端 -- 存活多耗时
		垃圾回收器
			回收器就是垃圾算法的实现
			##串行收集器
			    -XX:+UseSerialGC：策略为年轻代串行复制，年老代串行标记整理
			##并行收集器
			    -XX:+UseParallelGC
			    年轻代：暂停应用程序，多个垃圾收集线程并行的复制收集，线程数默认为CPU个数，CPU很多时，可用-XX:ParallelGCThreads= 设定线程数。
			    年老代：暂停应用程序，与串行收集器一样，单垃圾收集线程标记整理。
			##并发收集器
			    -XX:+UseConcMarkSweepGC
			    年轻代：同样是暂停应用程序，多个垃圾收集线程并行的复制收集。
			    年老代：则只有两次短暂停，其他时间应用程序与收集线程并发的清除。
			##增量并发收集器
			    在并发标记、清理的时候让GC线程、用户线程交叉运行，尽量减少GC线程的全程独占式执行
		内存泄漏
			程序在向系统申请分配内存空间后(new)，在使用完毕后未释放
		内存溢出
			程序向系统申请的内存空间超出了系统能给的
	调优
		参数


###java编译执行过程
编译成java字节码
类加载（加载到内存并校验、解析和初始化）
执行（解释成不同的机器码然后操作系统执行 保证跨平台）
###jvm调优
调优主要的目的是减少minor GC的频率和Full GC的次数,通过控制堆内存的各个部分的比例和GC策略
full GC
对整个堆进行整理
导致Full GC一般由于以下几种情况：
旧生代空间不足
调优时尽量让对象在新生代GC时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象 
Pemanet Generation空间不足
增大Perm Gen空间，避免太多静态对象 
统计得到的GC后晋升到旧生代的平均大小大于旧生代剩余空间
控制好新生代和旧生代的比例 
System.gc()被显示调用
垃圾回收不要手动触发，尽量依靠JVM自身的机制 

建议
-XX:PermSize尽量比-XX:MaxPermSize小，-XX:MaxPermSize>= 2 * -XX:PermSize, -XX:PermSize> 64m，一般对于4G内存的机器，-XX:MaxPermSize不会超过256m；
-Xms =  -Xmx（线上Server模式），以防止抖动，大小受操作系统和内存大小限制，如果是32位系统，则一般-Xms设置为1g-2g（假设有4g内存），在64位系统上，没有限制，不过一般为机器最大内存的一半左右；
-Xmn，在开发环境下，可以用-XX:NewSize和-XX:MaxNewSize来设置新生代的大小（-XX:NewSize<=-XX:MaxNewSize），在生产环境，建议只设置-Xmn，一般-Xmn的大小是-Xms的1/2左右，不要设置的过大或过小，过大导致老年代变小，频繁Full GC，过小导致minor GC频繁。如果不设置-Xmn，可以采用-XX:NewRatio=2来设置，也是一样的效果；
-Xss一般是不需要改的，默认值即可。
-XX:SurvivorRatio一般设置8-10左右，推荐设置为10，也即：Survivor区的大小是Eden区的1/10，一般来说，普通的Java程序应用，一次minorGC后，至少98%-99%的对象，都会消亡，所以，survivor区设置为Eden区的1/10左右，能使Survivor区容纳下10-20次的minor GC才满，然后再进入老年代，这个与 -XX:MaxTenuringThreshold的默认值15次也相匹配的。如果XX:SurvivorRatio设置的太小，会导致本来能通过minor回收掉的对象提前进入老年代，产生不必要的full gc；如果XX:SurvivorRatio设置的太大，会导致Eden区相应的被压缩。
-XX:MaxTenuringThreshold默认为15，也就是说，经过15次Survivor轮换（即15次minor GC），就进入老年代， 如果设置的小的话，则年轻代对象在survivor中存活的时间减小，提前进入年老代，对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代即被回收的概率。需要注意的是，设置了  -XX:MaxTenuringThreshold，并不代表着，对象一定在年轻代存活15次才被晋升进入老年代，它只是一个最大值，事实上，存在一个动态计算机制，计算每次晋入老年代的阈值，取阈值和MaxTenuringThreshold中较小的一个为准。
-XX:PretenureSizeThreshold一般采用默认值即可。

原则：
多数的Java应用不需要在服务器上进行GC优化；
多数导致GC问题的Java应用，都不是因为我们参数设置错误，而是代码问题；
在应用上线之前，先考虑将机器的JVM参数设置到最优（最适合）；
减少创建对象的数量；
减少使用全局变量和大对象；
GC优化是到最后不得已才采用的手段；
在实际使用中，分析GC情况优化代码比优化GC参数要多得多；

GC优化目的有两个
将转移到老年代的对象数量降低到最小；
减少full GC的执行时间；

监控和调优的一般步骤为：
1，监控GC的状态
使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化；
2，分析结果，判断是否需要优化
如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化；如果GC时间超过1-3秒，或者频繁GC，则必须优化；

注：如果满足下面的指标，则一般不需要进行GC：
Minor GC执行时间不到50ms；
Minor GC执行不频繁，约10秒一次；
Full GC执行时间不到1s；
Full GC执行频率不算频繁，不低于10分钟1次；