##网络编程
	五种io模式：
		阻塞 非阻塞 信号驱动 io复用 异步
		同步io：前四种都是同步io，io复用本质上也是同步I/O，因为都需要在读写事件就绪后自己负责进行读写，读写过程是阻塞的
		异步io: 异步I/O无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间
		阻塞：等待读写就绪会阻塞
		非阻塞：轮训读写，未就绪做其他事		
		读数据：将内核数据拷贝到用户空间  读就绪---数据到达内核空间
		写数据：将用户数据拷贝到内核  写就绪---内核空间未满
	名词
		内核空间&用户空间
			隔离内核程序和普通程序，保证安全性
			将虚拟存储空间划分为两部分内核空间和用户空间
		描述符
			表述指向文件的引用的抽象化概念，linux一切皆文件
			打开或创建文件时会返回文件描述符
		句柄
		服务器监听端口-最大连接数-描述符		
	socket处理
		Read request
		Decode request
		Process service
		Encode reply
		Send reply
	reactor模型
		原理
			连接进来时，不直接处理，告诉内核监听该连接的读写事件，当有事件发生时再丢到线程池处理,单线程处理了所有连接
		模式
			事件驱动机制 观察者模式 反应器
		核心
			描述符
				整数值，识别事件，socket连接，读写事件
			事件分离器
				demultiplexer
				循环等待事件
				使用io复用技术：select、poll、epoll等系统调用，用来等待一个或多个事件的发生
				将I/O复用技术封装成统一的接口，称为事件多路分离器
				调用者会被阻塞，直到描述符集上有事件发生
			事件处理器
				具体读写连接事件的处理，继承后实现处理函数
			Reactor管理器
				注册、删除事件处理器和相关的描述符
				使用事件分离器来等待事件的发生。一旦事件发生，分离每个事件，然后调度具体的事件处理器
			应用程序
				要做的仅仅是实现具体的事件处理器，然后把它注册到Reactor管理器中
		io复用技术
			通过一种机制，监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作
			select
				1.将fd集合从用户空间拷贝到内核空间
				2.调用select函数监视是否有fd就绪
					驱动中poll()函数执行 
					有数据返回mask掩码通知应用程序
					无数据返回0睡眠等待唤醒
				3.select返回后，将fd集合从内核空间拷贝到用户空间
				4.遍历fd集合找到就绪的fd
				5.支持的fd数量为1024（内核指定），可以使用多进程解决（Apache就是这样实现的）
			poll
				1.和select相似
				2.描述fd集合的方式不同，使用pollfd表示三个fd_set
				3.没有最大限制，但数量大性能也会下降
				4.同样需要遍历fd集合才能找到就绪的fd
			epoll			
				事件
					epitem结构体
					包含句柄和监控的事件类型
				epoll_create
					建立一个epoll对象（申请一个简易的文件系统）
					eventpoll结构体
						红黑树-存储需要监控的事件
						双链表-存储发生了的事件
				epoll_ctl
					向epoll对象添加进来的事件,挂载在红黑树中(红黑树插入高效)
					事件会与设备驱动程序建立回调关系
					当事件发生时，调用ep_poll_callback，将发生的事件添加到双链表中
				epoll_wait
					检查eventpoll对象中的双链表中是否有epitem元素，有则复制到用户空间
				高效
					红黑树 --- 不用将描述符从用户空间复制到内核
					双链表 --- 用户空间不用遍历获取就绪的描述符
					回调机制 --- 内核不用遍历
					100万个客户端同时与一个服务器进程保持着TCP连接，每一时刻，通常只有几百上千个TCP连接是活跃的
				工作模式
					LT：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件
					ET：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件
			线程模型
				单线程监听
				单线程监听+读写线程池
				多线程监听+读写线程池
	proactor模型
		事件分离器+回调函数
		Reactor模式
			事件分离者等待事件发生后传给事先注册的事件处理函数或者回调函数
			回调函数来做实际的读写操作
		Proactor模式
			直接发起一个异步读写操作，而实际的工作是由操作系统来完成的
			例如读事件发起时，需要提供的参数包括用于存放读到数据的缓存区，读的数据大小，以及这个请求完后的回调函数等信息
			事件分离者得知了这个请求，它默默等待这个请求的完成，然后调用回调函数处理
			回调函数处理时数据已经读写到缓存区，不用自己去做实际的读写操作
	NIO
		实现了reactor模式
		1.4,1.5使用的select、poll技术，1.8使用的epoll技术
		选择器
			单线程处理多通道，非阻塞模式（channel继承SelectableChannel）
			事件
				connect，accept，read，write
				不同channel可以注册的事件集合不同
				注册，处理，取消
			选择键（SelectionKey）
				通道，选择器，attach数据，感兴趣事件，已准备事件
				已注册键集合，已选择键集合，已取消键集合
				interestOps()
				readyOps()
				cancel()
				attach()
				attachment()
		通道
			register() 注册
			类型
		        FileChannel：从文件中读写数据。
		        DatagramChannel：能通过UDP读写网络中的数据。
		        SocketChannel：能通过TCP读写网络中的数据。
		        ServerSocketChannel：可以监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannel。
			读数据：通道到缓冲区
			写数据: 缓存区到通道
		缓存区
			capacity--容量  position--位置  limit--限制
			1.分配缓冲区 allocate（）
			1.将数据写入缓冲区     ---- 写模式
			2.调用buffer.flip（）  ---- 写入模式切换到读取模式
			3.从缓冲区读取数据     ---- 读模式
			4.清除缓冲区
				buffer.clear（）   ---- 清除所有
				buffer.compact（） ----清除已读